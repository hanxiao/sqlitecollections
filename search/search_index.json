{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Documentation for version: 0.5.0 sqlitecollections is a sort of containers that are backended by sqlite3 DB and are compatible with corresponding built-in collections. Since containers consume disk space instead of RAM, they can handle large amounts of data even in environments with limited RAM. Migrating from existing code using the built-in container is as simple as importing the library and changing the constructor. The elements of the container are automatically serialized and stored in the sqlite3 database, and are automatically read from the sqlite3 database and deserialized when accessed. Current version supports List (mutable sequence), Dict (mutable mapping) and Set (mutable set) and almost all methods are compatible with list, dict and set respectively. Installation pip install sqlitecollections Example import sqlite3 from sqlitecollections import List , Set , Dict conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" ] ) print ( l [ 2 ]) #> Carol print ( len ( l )) #> 3 l . append ( \"Dave\" ) print ( l . index ( \"Bob\" )) #> 2 d = Dict [ str , str ]( connection = conn , table_name = \"dict_example\" , data = { \"a\" : \"Alice\" , \"b\" : \"Bob\" } ) print ( d [ \"a\" ]) #> Alice d [ \"c\" ] = \"Carol\" print ( list ( d . keys ())) #> ['a', 'b', 'c'] print ( list ( d . values ())) #> ['Alice', 'Bob', 'Carol'] s = Set [ str ]( connection = conn , table_name = \"set_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" , \"Dave\" ] ) print ( \"Ellen\" in s ) #> False print ( \"Alice\" in s ) #> True print ( list ( s . intersection ([ \"Alice\" , \"Carol\" ]))) #> ['Alice', 'Carol'] The database is updated with each operation, so even if we exit from the python process at this point, the database will still be in the same state and the next time we use the same file, we will be able to use the container from the last time we terminated. import sqlite3 from sqlitecollections import List conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , ) print ( len ( l )) #> 4 print ( l [ 2 ]) #> Carol Pros and cons for built-in containers Pros Save memory usage. Once the database is built, loading time is almost zero, even for huge data. Cons Each operation has the overhead of serialize/deserialize. Some operations are incompatible and unavailable. For example, directly rewriting the mutable elements of a container.","title":"Overview"},{"location":"#overview","text":"Documentation for version: 0.5.0 sqlitecollections is a sort of containers that are backended by sqlite3 DB and are compatible with corresponding built-in collections. Since containers consume disk space instead of RAM, they can handle large amounts of data even in environments with limited RAM. Migrating from existing code using the built-in container is as simple as importing the library and changing the constructor. The elements of the container are automatically serialized and stored in the sqlite3 database, and are automatically read from the sqlite3 database and deserialized when accessed. Current version supports List (mutable sequence), Dict (mutable mapping) and Set (mutable set) and almost all methods are compatible with list, dict and set respectively.","title":"Overview"},{"location":"#installation","text":"pip install sqlitecollections","title":"Installation"},{"location":"#example","text":"import sqlite3 from sqlitecollections import List , Set , Dict conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" ] ) print ( l [ 2 ]) #> Carol print ( len ( l )) #> 3 l . append ( \"Dave\" ) print ( l . index ( \"Bob\" )) #> 2 d = Dict [ str , str ]( connection = conn , table_name = \"dict_example\" , data = { \"a\" : \"Alice\" , \"b\" : \"Bob\" } ) print ( d [ \"a\" ]) #> Alice d [ \"c\" ] = \"Carol\" print ( list ( d . keys ())) #> ['a', 'b', 'c'] print ( list ( d . values ())) #> ['Alice', 'Bob', 'Carol'] s = Set [ str ]( connection = conn , table_name = \"set_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" , \"Dave\" ] ) print ( \"Ellen\" in s ) #> False print ( \"Alice\" in s ) #> True print ( list ( s . intersection ([ \"Alice\" , \"Carol\" ]))) #> ['Alice', 'Carol'] The database is updated with each operation, so even if we exit from the python process at this point, the database will still be in the same state and the next time we use the same file, we will be able to use the container from the last time we terminated. import sqlite3 from sqlitecollections import List conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , ) print ( len ( l )) #> 4 print ( l [ 2 ]) #> Carol","title":"Example"},{"location":"#pros-and-cons-for-built-in-containers","text":"","title":"Pros and cons for built-in containers"},{"location":"#pros","text":"Save memory usage. Once the database is built, loading time is almost zero, even for huge data.","title":"Pros"},{"location":"#cons","text":"Each operation has the overhead of serialize/deserialize. Some operations are incompatible and unavailable. For example, directly rewriting the mutable elements of a container.","title":"Cons"},{"location":"development/","text":"Development Tests, type checking and linting locally To run tests, type checking and linting locally, you'll need to have python 3.6 , 3.7 , 3.8 and 3.9 installed. We use tox to run tests and type checking on all the supported python versions. You can set up the development environment with the following commands: git clone git@github.com:osoken/sqlitecollections.git cd sqlitecollections python -m venv .venv source ./.venv/bin/activate pip install -e .[dev] Then, run tests is as easy as: tox After a while, you'll see the following message at the bottom of the long logs from pytest and others. __________________ summary __________________ lint: commands succeeded py36: commands succeeded py37: commands succeeded py38: commands succeeded py39: commands succeeded congratulations :) Compatibility policy We aim to implement containers that are as compatible as possible with the built-in containers, but we have a few implementations that intentionally behave differently. Normal behavior will be compatible, but in case of errors it may be different. The constructor arguments are not compatible, as they require arguments specific to this package's container, such as sqlite3 DB file paths and serialization methods. Dict 's item order is guaranteed to be insertion order not only for python 3.7 and upper but for all versions. Dict.fromkeys class method is not provided. Any member in the container cannot be mutated directly. If you want to mutate any member, mutate it via temporary variable then write it back. from sqlitecollections import Dict x = Dict ( data = { \"a\" : []}) # create {\"a\": []} x [ \"a\" ] . append ( \"b\" ) # try to mutate the empty list print ( x [ \"a\" ]) # not [\"b\"] but [] temp = x [ \"a\" ] # temporarily substitute the list to a variable temp . append ( \"b\" ) # mutate the temporary variable x [ \"a\" ] = temp # then, write it back print ( x [ \"a\" ]) # now, we get [\"b\"]","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#tests-type-checking-and-linting-locally","text":"To run tests, type checking and linting locally, you'll need to have python 3.6 , 3.7 , 3.8 and 3.9 installed. We use tox to run tests and type checking on all the supported python versions. You can set up the development environment with the following commands: git clone git@github.com:osoken/sqlitecollections.git cd sqlitecollections python -m venv .venv source ./.venv/bin/activate pip install -e .[dev] Then, run tests is as easy as: tox After a while, you'll see the following message at the bottom of the long logs from pytest and others. __________________ summary __________________ lint: commands succeeded py36: commands succeeded py37: commands succeeded py38: commands succeeded py39: commands succeeded congratulations :)","title":"Tests, type checking and linting locally"},{"location":"development/#compatibility-policy","text":"We aim to implement containers that are as compatible as possible with the built-in containers, but we have a few implementations that intentionally behave differently. Normal behavior will be compatible, but in case of errors it may be different. The constructor arguments are not compatible, as they require arguments specific to this package's container, such as sqlite3 DB file paths and serialization methods. Dict 's item order is guaranteed to be insertion order not only for python 3.7 and upper but for all versions. Dict.fromkeys class method is not provided. Any member in the container cannot be mutated directly. If you want to mutate any member, mutate it via temporary variable then write it back. from sqlitecollections import Dict x = Dict ( data = { \"a\" : []}) # create {\"a\": []} x [ \"a\" ] . append ( \"b\" ) # try to mutate the empty list print ( x [ \"a\" ]) # not [\"b\"] but [] temp = x [ \"a\" ] # temporarily substitute the list to a variable temp . append ( \"b\" ) # mutate the temporary variable x [ \"a\" ] = temp # then, write it back print ( x [ \"a\" ]) # now, we get [\"b\"]","title":"Compatibility policy"},{"location":"install/","text":"Install pip install sqlitecollections","title":"Install"},{"location":"install/#install","text":"pip install sqlitecollections","title":"Install"},{"location":"usage/common/","text":"","title":"Common"},{"location":"usage/dict/","text":"Dict Dict is a container compatible with the built-in dict , which serializes keys and values and stores them in a sqlite3 database. It preserves insertion order for all supported python versions. Dict[KT, VT](...) Constructor. Type Parameters: KT : key type VT : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[VT], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], VT] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. key_serializer : Callable[[KT], bytes] , optional, default= None ; Function to serialize key. If None , serializer is used. key_deserializer : Callable[[bytes], KT] , optional, default= None ; Function to deserialize key. If None , deserializer is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] , optional, defualt= None ; Initial data. len(d) Return the number of items in d: Dict[KT, VT] Return value: int : The number of items in d d[key] Get item of d with key key . Raises a KeyError if key is not in the map. Arguments: key : KT ; Key to retrieve corresponding value Return value: VT : Item of d with key key d[key] = value Set d[key] to value . Arguments: key : KT ; Key to be set value : VT ; Value to be set Return value: None del d[key] Delete d[key] . Arguments: key : KT ; Key to be deleted Return value: None key in d Return whether if key is in d Arguments: key : KT ; Key to be checked Return value: bool : True if key is in d and False otherwise. key not in d Return whether if key is not in d Arguments: key : KT ; Key to be checked Return value: bool : True if key is not in d and False otherwise. iter(d) Return an iterator over the keys of d Return value: Iterator[KT] : an iterator over the keys of d clear() Remove all items from the dictionary Return value: None copy() Return a copy of the dictionary. The actual behavior is to create a table with a unique table name and copy the keys and the values to the new table. Therefore, unlike the built-in dict copy, the behavior is similar to deep copy. Be aware that the copied dictionary is volatile. Return value: Dict[KT, VT] : A volatile copy of the dictionary. get(key[, default]) Return the value for key if key is in the dictionary, else default . If default is not given, it defaults to None , so that this method never raises a KeyError . Arguments: key : KT ; Key to retrieve corresponding value if exists. default : VT , optional, default= None ; Default value in case that key is not in the dictionary Return value: VT : Item of the dictionary with key key if key is in the dictionary, default otherwise. items() Return a new view of the dictionary\u2019s items (key-value pairs). Return value: ItemsView : View object of the dictionary's items keys() Return a new view of the dictionary's keys. Return value: KeysView : View object of the dictionary's keys pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default . If default is not given and key is not in the dictionary, a KeyError is raised. Arguments: key : KT ; Key to retrieve corresponding value if exists. default : VT , optional, default= None ; Default value in case that key is not in the dictionary Return value: VT : Item of the dictionary with key key if key is in the dictionary, default otherwise. popitem() Remove and return a key-value pair from the dictionary. Pairs are returned in LIFO order. If the dictionary is empty, raises a KeyError . Return value: Tuple[KT, VT] : Key-value pair that were last inserted into the dictionary reversed(d) Return a reverse iterator over the keys of the dictionary. (provided only python version 3.8 and above) Return value: Iterator[KT] : Reverse iterator over the keys of the dictionary setdefault(key[, default]) If key is in the dictionary, return its value. If not, insert key with a value of default and return default . Arguments: key : KT ; Key to retrieve or set the value default : VT , optional, default= None ; Value to be set if key is not in the dictionary Return value: VT : Item of the dictionary with key key if key is in the dictionary, default otherwise. update([other]) Update the dictionary with the key-value pairs from other , overwriting existing keys. Arguments: other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] , optional; Key-value pairs to be added Return value: None values() Return a new view of the dictionary's values. Return value: ValuesView : View object of the dictionary's values d | other Create a new dictionary with the merged keys and values of d and other , which must both be dictionaries. The values of other take priority when d and other share keys. The return value is volatile by default. (provided only python version 3.9 and above) Arguments: other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] ; Key-value pairs to be merged Return value: Dict[KT, VT] : A new volatile dictionary object. d |= other Update the dictionary d with keys and values from other . (provided only python version 3.9 and above) Arguments: other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] ; Key-value pairs to be merged Return value: Dict[KT, VT] : The dictionary object.","title":"Dict"},{"location":"usage/dict/#dict","text":"Dict is a container compatible with the built-in dict , which serializes keys and values and stores them in a sqlite3 database. It preserves insertion order for all supported python versions.","title":"Dict"},{"location":"usage/dict/#dictkt-vt","text":"Constructor.","title":"Dict[KT, VT](...)"},{"location":"usage/dict/#type-parameters","text":"KT : key type VT : value type","title":"Type Parameters:"},{"location":"usage/dict/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[VT], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], VT] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. key_serializer : Callable[[KT], bytes] , optional, default= None ; Function to serialize key. If None , serializer is used. key_deserializer : Callable[[bytes], KT] , optional, default= None ; Function to deserialize key. If None , deserializer is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] , optional, defualt= None ; Initial data.","title":"Arguments:"},{"location":"usage/dict/#lend","text":"Return the number of items in d: Dict[KT, VT]","title":"len(d)"},{"location":"usage/dict/#return-value","text":"int : The number of items in d","title":"Return value:"},{"location":"usage/dict/#dkey","text":"Get item of d with key key . Raises a KeyError if key is not in the map.","title":"d[key]"},{"location":"usage/dict/#arguments_1","text":"key : KT ; Key to retrieve corresponding value","title":"Arguments:"},{"location":"usage/dict/#return-value_1","text":"VT : Item of d with key key","title":"Return value:"},{"location":"usage/dict/#dkey-value","text":"Set d[key] to value .","title":"d[key] = value"},{"location":"usage/dict/#arguments_2","text":"key : KT ; Key to be set value : VT ; Value to be set","title":"Arguments:"},{"location":"usage/dict/#return-value_2","text":"None","title":"Return value:"},{"location":"usage/dict/#del-dkey","text":"Delete d[key] .","title":"del d[key]"},{"location":"usage/dict/#arguments_3","text":"key : KT ; Key to be deleted","title":"Arguments:"},{"location":"usage/dict/#return-value_3","text":"None","title":"Return value:"},{"location":"usage/dict/#key-in-d","text":"Return whether if key is in d","title":"key in d"},{"location":"usage/dict/#arguments_4","text":"key : KT ; Key to be checked","title":"Arguments:"},{"location":"usage/dict/#return-value_4","text":"bool : True if key is in d and False otherwise.","title":"Return value:"},{"location":"usage/dict/#key-not-in-d","text":"Return whether if key is not in d","title":"key not in d"},{"location":"usage/dict/#arguments_5","text":"key : KT ; Key to be checked","title":"Arguments:"},{"location":"usage/dict/#return-value_5","text":"bool : True if key is not in d and False otherwise.","title":"Return value:"},{"location":"usage/dict/#iterd","text":"Return an iterator over the keys of d","title":"iter(d)"},{"location":"usage/dict/#return-value_6","text":"Iterator[KT] : an iterator over the keys of d","title":"Return value:"},{"location":"usage/dict/#clear","text":"Remove all items from the dictionary","title":"clear()"},{"location":"usage/dict/#return-value_7","text":"None","title":"Return value:"},{"location":"usage/dict/#copy","text":"Return a copy of the dictionary. The actual behavior is to create a table with a unique table name and copy the keys and the values to the new table. Therefore, unlike the built-in dict copy, the behavior is similar to deep copy. Be aware that the copied dictionary is volatile.","title":"copy()"},{"location":"usage/dict/#return-value_8","text":"Dict[KT, VT] : A volatile copy of the dictionary.","title":"Return value:"},{"location":"usage/dict/#getkey-default","text":"Return the value for key if key is in the dictionary, else default . If default is not given, it defaults to None , so that this method never raises a KeyError .","title":"get(key[, default])"},{"location":"usage/dict/#arguments_6","text":"key : KT ; Key to retrieve corresponding value if exists. default : VT , optional, default= None ; Default value in case that key is not in the dictionary","title":"Arguments:"},{"location":"usage/dict/#return-value_9","text":"VT : Item of the dictionary with key key if key is in the dictionary, default otherwise.","title":"Return value:"},{"location":"usage/dict/#items","text":"Return a new view of the dictionary\u2019s items (key-value pairs).","title":"items()"},{"location":"usage/dict/#return-value_10","text":"ItemsView : View object of the dictionary's items","title":"Return value:"},{"location":"usage/dict/#keys","text":"Return a new view of the dictionary's keys.","title":"keys()"},{"location":"usage/dict/#return-value_11","text":"KeysView : View object of the dictionary's keys","title":"Return value:"},{"location":"usage/dict/#popkey-default","text":"If key is in the dictionary, remove it and return its value, else return default . If default is not given and key is not in the dictionary, a KeyError is raised.","title":"pop(key[, default])"},{"location":"usage/dict/#arguments_7","text":"key : KT ; Key to retrieve corresponding value if exists. default : VT , optional, default= None ; Default value in case that key is not in the dictionary","title":"Arguments:"},{"location":"usage/dict/#return-value_12","text":"VT : Item of the dictionary with key key if key is in the dictionary, default otherwise.","title":"Return value:"},{"location":"usage/dict/#popitem","text":"Remove and return a key-value pair from the dictionary. Pairs are returned in LIFO order. If the dictionary is empty, raises a KeyError .","title":"popitem()"},{"location":"usage/dict/#return-value_13","text":"Tuple[KT, VT] : Key-value pair that were last inserted into the dictionary","title":"Return value:"},{"location":"usage/dict/#reversedd","text":"Return a reverse iterator over the keys of the dictionary. (provided only python version 3.8 and above)","title":"reversed(d)"},{"location":"usage/dict/#return-value_14","text":"Iterator[KT] : Reverse iterator over the keys of the dictionary","title":"Return value:"},{"location":"usage/dict/#setdefaultkey-default","text":"If key is in the dictionary, return its value. If not, insert key with a value of default and return default .","title":"setdefault(key[, default])"},{"location":"usage/dict/#arguments_8","text":"key : KT ; Key to retrieve or set the value default : VT , optional, default= None ; Value to be set if key is not in the dictionary","title":"Arguments:"},{"location":"usage/dict/#return-value_15","text":"VT : Item of the dictionary with key key if key is in the dictionary, default otherwise.","title":"Return value:"},{"location":"usage/dict/#updateother","text":"Update the dictionary with the key-value pairs from other , overwriting existing keys.","title":"update([other])"},{"location":"usage/dict/#arguments_9","text":"other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] , optional; Key-value pairs to be added","title":"Arguments:"},{"location":"usage/dict/#return-value_16","text":"None","title":"Return value:"},{"location":"usage/dict/#values","text":"Return a new view of the dictionary's values.","title":"values()"},{"location":"usage/dict/#return-value_17","text":"ValuesView : View object of the dictionary's values","title":"Return value:"},{"location":"usage/dict/#d-other","text":"Create a new dictionary with the merged keys and values of d and other , which must both be dictionaries. The values of other take priority when d and other share keys. The return value is volatile by default. (provided only python version 3.9 and above)","title":"d | other"},{"location":"usage/dict/#arguments_10","text":"other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] ; Key-value pairs to be merged","title":"Arguments:"},{"location":"usage/dict/#return-value_18","text":"Dict[KT, VT] : A new volatile dictionary object.","title":"Return value:"},{"location":"usage/dict/#d-other_1","text":"Update the dictionary d with keys and values from other . (provided only python version 3.9 and above)","title":"d |= other"},{"location":"usage/dict/#arguments_11","text":"other : Mapping[KT, VT] or Iterable[Tuple[KT, VT]] ; Key-value pairs to be merged","title":"Arguments:"},{"location":"usage/dict/#return-value_19","text":"Dict[KT, VT] : The dictionary object.","title":"Return value:"},{"location":"usage/list/","text":"List List is a container compatible with the built-in list , which serializes values and stores them in a sqlite3 database. List[T](...) Constructor. Type Parameters: T : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"List"},{"location":"usage/list/#list","text":"List is a container compatible with the built-in list , which serializes values and stores them in a sqlite3 database.","title":"List"},{"location":"usage/list/#listt","text":"Constructor.","title":"List[T](...)"},{"location":"usage/list/#type-parameters","text":"T : value type","title":"Type Parameters:"},{"location":"usage/list/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Arguments:"},{"location":"usage/set/","text":"Set Set is a container compatible with the built-in set , which serializes values and stores them in a sqlite3 database. Set[T](...) Constructor. Type Parameters: T : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Set"},{"location":"usage/set/#set","text":"Set is a container compatible with the built-in set , which serializes values and stores them in a sqlite3 database.","title":"Set"},{"location":"usage/set/#sett","text":"Constructor.","title":"Set[T](...)"},{"location":"usage/set/#type-parameters","text":"T : value type","title":"Type Parameters:"},{"location":"usage/set/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Arguments:"}]}