{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Documentation for version: v0.5.0 sqlitecollections is a sort of containers that are backended by sqlite3 DB and are compatible with corresponding built-in collections. The elements of the container are automatically serialized and stored in the sqlite3 database, and are automatically read from the sqlite3 database and deserialized when accessed. Current version supports List (mutable sequence), Dict (mutable mapping) and Set (mutable set) and almost all methods are compatible with list , dict and set respectively. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import sqlite3 from sqlitecollections import List , Set , Dict conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" ] ) print ( l [ 2 ]) #> Carol print ( len ( l )) #> 3 l . append ( \"Dave\" ) print ( l . index ( \"Bob\" )) #> 2 d = Dict [ str , str ]( connection = conn , table_name = \"dict_example\" , data = { \"a\" : \"Alice\" , \"b\" : \"Bob\" } ) print ( d [ \"a\" ]) #> Alice d [ \"c\" ] = \"Carol\" print ( list ( d . keys ())) #> ['a', 'b', 'c'] print ( list ( d . values ())) #> ['Alice', 'Bob', 'Carol'] s = Set [ str ]( connection = conn , table_name = \"set_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" , \"Dave\" ] ) print ( \"Ellen\" in s ) #> False print ( \"Alice\" in s ) #> True print ( list ( s . intersection ([ \"Alice\" , \"Carol\" ]))) #> ['Alice', 'Carol'] The database is updated with each operation, so even if you exit from the python process at this point, the database will still be in the same state and the next time we use the same file, we will be able to use the container from the last time we terminated. 1 2 3 4 5 6 7 8 9 10 11 12 13 import sqlite3 from sqlitecollections import List conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , ) print ( len ( l )) #> 4 print ( l [ 2 ]) #> Carol Pros and cons for built-in containers Pros Save memory usage. Once the database is built, loading time is almost zero, even for huge data. Cons Each operation has the overhead of serialize/deserialize. Some operations are incompatible and unavailable. For example, directly rewriting the mutable elements of a container.","title":"Overview"},{"location":"#overview","text":"Documentation for version: v0.5.0 sqlitecollections is a sort of containers that are backended by sqlite3 DB and are compatible with corresponding built-in collections. The elements of the container are automatically serialized and stored in the sqlite3 database, and are automatically read from the sqlite3 database and deserialized when accessed. Current version supports List (mutable sequence), Dict (mutable mapping) and Set (mutable set) and almost all methods are compatible with list , dict and set respectively.","title":"Overview"},{"location":"#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import sqlite3 from sqlitecollections import List , Set , Dict conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" ] ) print ( l [ 2 ]) #> Carol print ( len ( l )) #> 3 l . append ( \"Dave\" ) print ( l . index ( \"Bob\" )) #> 2 d = Dict [ str , str ]( connection = conn , table_name = \"dict_example\" , data = { \"a\" : \"Alice\" , \"b\" : \"Bob\" } ) print ( d [ \"a\" ]) #> Alice d [ \"c\" ] = \"Carol\" print ( list ( d . keys ())) #> ['a', 'b', 'c'] print ( list ( d . values ())) #> ['Alice', 'Bob', 'Carol'] s = Set [ str ]( connection = conn , table_name = \"set_example\" , data = [ \"Alice\" , \"Bob\" , \"Carol\" , \"Dave\" ] ) print ( \"Ellen\" in s ) #> False print ( \"Alice\" in s ) #> True print ( list ( s . intersection ([ \"Alice\" , \"Carol\" ]))) #> ['Alice', 'Carol'] The database is updated with each operation, so even if you exit from the python process at this point, the database will still be in the same state and the next time we use the same file, we will be able to use the container from the last time we terminated. 1 2 3 4 5 6 7 8 9 10 11 12 13 import sqlite3 from sqlitecollections import List conn = sqlite3 . connect ( \"collections.db\" ) l = List [ str ]( connection = conn , table_name = \"list_example\" , ) print ( len ( l )) #> 4 print ( l [ 2 ]) #> Carol","title":"Example"},{"location":"#pros-and-cons-for-built-in-containers","text":"","title":"Pros and cons for built-in containers"},{"location":"#pros","text":"Save memory usage. Once the database is built, loading time is almost zero, even for huge data.","title":"Pros"},{"location":"#cons","text":"Each operation has the overhead of serialize/deserialize. Some operations are incompatible and unavailable. For example, directly rewriting the mutable elements of a container.","title":"Cons"},{"location":"install/","text":"Install 1 pip install sqlitecollections","title":"Install"},{"location":"install/#install","text":"1 pip install sqlitecollections","title":"Install"},{"location":"usage/common/","text":"","title":"Common"},{"location":"usage/dict/","text":"Dict Dict is a container compatible with the built-in dict , which serializes keys and values and stores them in a sqlite3 database. It preserves insertion order for all supported python versions. Dict[KT, VT](...) Constructor. Type Parameters: KT : key type VT : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[VT], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], VT] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. key_serializer : Callable[[KT], bytes] , optional, default= None ; Function to serialize key. If None , serializer is used. key_deserializer : Callable[[bytes], KT] , optional, default= None ; Function to deserialize key. If None , deserializer is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Mapping[KT, VT] , optional, defualt= None ; Initial data. len(d) Return the number of items in d: Dict[KT, VT] Return value: int : The number of items in d d[key] Get item of d with key key . Arguments: key : KT ; Return the item of d with key key . Raises a KeyError if key is not in the map Return value: VT : Item of d with key key d[key] = value Set d[key] to value . Arguments: key : KT ; Key to be set value : VT ; Value to be set Return value: None","title":"Dict"},{"location":"usage/dict/#dict","text":"Dict is a container compatible with the built-in dict , which serializes keys and values and stores them in a sqlite3 database. It preserves insertion order for all supported python versions.","title":"Dict"},{"location":"usage/dict/#dictkt-vt","text":"Constructor.","title":"Dict[KT, VT](...)"},{"location":"usage/dict/#type-parameters","text":"KT : key type VT : value type","title":"Type Parameters:"},{"location":"usage/dict/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[VT], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], VT] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. key_serializer : Callable[[KT], bytes] , optional, default= None ; Function to serialize key. If None , serializer is used. key_deserializer : Callable[[bytes], KT] , optional, default= None ; Function to deserialize key. If None , deserializer is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Mapping[KT, VT] , optional, defualt= None ; Initial data.","title":"Arguments:"},{"location":"usage/dict/#lend","text":"Return the number of items in d: Dict[KT, VT]","title":"len(d)"},{"location":"usage/dict/#return-value","text":"int : The number of items in d","title":"Return value:"},{"location":"usage/dict/#dkey","text":"Get item of d with key key .","title":"d[key]"},{"location":"usage/dict/#arguments_1","text":"key : KT ; Return the item of d with key key . Raises a KeyError if key is not in the map","title":"Arguments:"},{"location":"usage/dict/#return-value_1","text":"VT : Item of d with key key","title":"Return value:"},{"location":"usage/dict/#dkey-value","text":"Set d[key] to value .","title":"d[key] = value"},{"location":"usage/dict/#arguments_2","text":"key : KT ; Key to be set value : VT ; Value to be set","title":"Arguments:"},{"location":"usage/dict/#return-value_2","text":"None","title":"Return value:"},{"location":"usage/list/","text":"List List is a container compatible with the built-in list , which serializes values and stores them in a sqlite3 database. List[T](...) Constructor. Type Parameters: T : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"List"},{"location":"usage/list/#list","text":"List is a container compatible with the built-in list , which serializes values and stores them in a sqlite3 database.","title":"List"},{"location":"usage/list/#listt","text":"Constructor.","title":"List[T](...)"},{"location":"usage/list/#type-parameters","text":"T : value type","title":"Type Parameters:"},{"location":"usage/list/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Arguments:"},{"location":"usage/set/","text":"Set Set is a container compatible with the built-in set , which serializes values and stores them in a sqlite3 database. Set[T](...) Constructor. Type Parameters: T : value type Arguments: connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Set"},{"location":"usage/set/#set","text":"Set is a container compatible with the built-in set , which serializes values and stores them in a sqlite3 database.","title":"Set"},{"location":"usage/set/#sett","text":"Constructor.","title":"Set[T](...)"},{"location":"usage/set/#type-parameters","text":"T : value type","title":"Type Parameters:"},{"location":"usage/set/#arguments","text":"connection : str or sqlite3.Connection , optional, default= None ; If None , temporary file is automatically created. If connection is a str , it will be used as the sqlite3 database file name. You can pass a sqlite3.Connection directly. table_name : str , optional, default= None ; Table name of this container. If None , an auto-generated unique name will be used. Available characters are letters, numbers, and underscores ( _ ). serializer : Callable[[T], bytes] , optional, default= None ; Function to serialize value. If None , pickle.dumps is used. deserializer : Callable[[bytes], T] , optional, default= None ; Function to deserialize value. If None , pickle.loads is used. persist : bool , optional, default= True ; If True , table won't be deleted even when the object is deleted. If False , the table is deleted when this object is deleted. rebuild_strategy : RebuildStrategy , optional, default= RebuildStrategy.CHECK_WITH_FIRST_ELEMENT ; Rebuild strategy. data : Iterable[T] , optional, defualt= None ; Initial data.","title":"Arguments:"}]}